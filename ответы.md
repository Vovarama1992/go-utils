Чем горутины отличаются от потоков ОС?

Горутина — это лёгкий поток Go, который занимает поток ОС только во время выполнения. При блокировке или завершении она освобождает поток. Поэтому Go может эффективно обрабатывать тысячи горутин одновременно, без большого расхода памяти.

Когда стоит использовать sync.Mutex, а когда — каналы?

Когда горутины общаются — используем канал.
Когда горутины делят общую область данных — используем мьютекс.


Что такое work stealing в планировщике Go?

Каждый P (планировщик) — это слот исполнения. Он хранит очередь goroutine. Поток (M) может исполнять задачи только если прикреплён к P.
Если у P очередь пуста — он временно простаивает. Тогда он пытается украсть goroutine из конца очереди другого P. Это и называется work stealing.

Как планировщик Go обрабатывает блокирующие операции? 

Когда goroutine выполняет блокирующую операцию, она снимается с исполнения и ставится в очередь ожидания (например, у канала, мьютекса или poller’а).
Когда условие разблокировки выполнено — она просто добавляется обратно в очередь планировщика и исполняется, когда дойдёт очередь.

Какие алгоритмы лежат в основе сборщика мусора в Go?

В Go память собирается по достижимости: если до объекта нельзя дойти по ссылкам из стека или глобальных переменных, он считается мусором. Сборщик в фоне отмечает живые объекты, чистит мёртвые, а специальный механизм следит за тем, чтобы не потерять новые ссылки во время этого процесса.

Чтобы избежать утечек памяти в Go, важно правильно управлять жизненным циклом горутин с помощью контекстов или каналов, всегда закрывать каналы, не оставлять горутины висящими на блокирующих операциях, контролировать буферизацию каналов и избегать бессмысленного создания горутин без завершения.

Зачем в Go используются пустые структуры?

весят 0 байт. когда нужно просто зафикисровать факт, что что-то есть или передано

Чем интерфейсы в Go отличаются от интерфейсов в других языках?

В Go тип удовлетворяет интерфейсу автоматически, если реализует все методы.
В других языках нужно явно указать implements / interface.

В Go структура может реализовывать интерфейс без явного намерения.

Как нарушение Single Responsibility усложняет поддержку?

Если класс делает всё подряд — легко что-то ломается.
Границы ответственности размыты.
Дополнительная логика подключается через инъекцию, а не встраивается.
Так структура остаётся чистой, изменения — безопасными.